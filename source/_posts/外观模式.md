---
title: 外观模式
tags:
  - Java
  - 设计模式
categories:
  - Java
abbrlink: 33100
date: 2019-12-20 08:59:42
---
{% cq %}
外观模式(Facade Pattern) 隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。这种类型的设计模式属于结构型模式，它向现有的系统添加一个接口，来隐藏系统的复杂性。  
这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。
{% endcq %}
{% cq %}
**外观模式定义了一个将子系统的一组接口集成在一起的高层接口，以提供一个一致的界面。通过这个界面，其他系统可以方便地嗲用子系统中的功能，而忽略子系统内部发生的变化。**
{% endcq %}

# 介绍：
- **意图：** 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
- **主要解决：** 降低访问复杂系统的内部子系统时的复杂度，简化客户端与之的接口。
- **何时使用：** 
1. 客户端不需要知道系统内部的复杂练习，整个系统只需提供一个“接待员”即可，
2. 定义系统的入口。
3. 为一个比较复杂的子系统提供一个简单的接口。
4. 将客户程序与子系统的实现部分分离，提高子系统的独立性和可移植性。
5. 简化子系统间的依赖关系。
- **如何解决：** 客户端不予系统耦合，外观类与系统耦合。
- **关键代码：** 在客户端和复杂系统之间再加一层，这一层将调用顺序、依赖关系等处理好。
- **应用实例：** 
1. 去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。
2. java的三层开发模式。{% post_link Java-开发模式 %}
- ***优点：*** 
1. 减少系统相互依赖。
2. 提高灵活性。
3. 提高安全性。
- ***缺点：*** 不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。
- **使用场景：** 
1. 为复杂的模块或子系统提供外界访问的模块。
2. 子系统相对独立。
3. 预防低水平人员带来的风险。
- ***注意事项：*** 在层次结构中，可以使用外观模式定义系统中每一层的入口。
# 实现：
> 创建一个Shape接口和实现了Shape接口的实体类。下一步是定义一个外观类ShapeMaker。  
ShapeMaker类使用实体类来代表用户对这些类的调用。FacadePatternDemo，我们演示类使用ShapeMaker类来显示结果。
{% asset_img 外观模式 外观模式UML图 %}
## 步骤1：定义接口

> 创建一个接口。

```java
/*Shape.java*/
public interface Shape {
   void draw();
}
```

## 步骤2：实现接口
> 创建实现接口的实体类。

```java
/*Rectangle.java*/
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Rectangle::draw()");
   }
}
/*Square.java*/
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Square::draw()");
   }
}
/*Circle.java*/
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Circle::draw()");
   }
}
```
## 步骤3：
> 创建一个外观类：

```java
/*ShapeMaker.java*/
public class ShapeMaker {
   private Shape circle;
   private Shape rectangle;
   private Shape square;
 
   public ShapeMaker() {
      circle = new Circle();
      rectangle = new Rectangle();
      square = new Square();
   }
 
   public void drawCircle(){
      circle.draw();
   }
   public void drawRectangle(){
      rectangle.draw();
   }
   public void drawSquare(){
      square.draw();
   }
}
```
## 步骤4：调用外观类
> 使用该外观类画出各种类型的形状。

```java
/*FacadePatternDemo.java*/
public class FacadePatternDemo {
   public static void main(String[] args) {
      ShapeMaker shapeMaker = new ShapeMaker();
 
      shapeMaker.drawCircle();
      shapeMaker.drawRectangle();
      shapeMaker.drawSquare();      
   }
}
```

## 步骤5：
> 执行程序，输出结果：

```java
Circle::draw()
Rectangle::draw()
Square::draw()
```

{% cq %}
1. 在设计外观时，不需要增加额外的功能。
2. 不要从外观方法中返回子系统中的组件给客户。例如：有一个下面的方法：CreditCardgetCreditCard（）会报漏子系统的细节给客户。应用就不能从应用外观模式中取得最大的好处。
3. 应用外观的目的是提供一个高层次的接口。因此，外观方法最适合提供特定的高层次的业务服务，而不是进行底层次的单独的业务执行
{% endcq %}